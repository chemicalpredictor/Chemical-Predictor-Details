<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Інтерактивна таблиця — баланс реакції + вектори (fixed layout)</title>

<style>
  :root{ --accent:#2a9df4; --pos:#1e6ed1; --neg:#d13b3b; --border:#9aa; }
  /* Box sizing reset to avoid unexpected overflow */
  *, *::before, *::after { box-sizing: border-box; }

  body{background:#f6f9fc; margin:0; padding:0; font-family:Arial, sans-serif; color:#222;}
  .chem-wrap{ max-width:1200px; width:calc(100% - 32px); margin:24px auto; background:#fff; padding:16px; border-radius:12px; box-shadow:0 2px 6px rgba(0,0,0,0.08); overflow:hidden; }
  .title{text-align:center; font-weight:700; margin-bottom:6px; font-size:20px;}
  .eq{ text-align:center; margin-bottom:12px; font-size:18px;}
  .formula-box{display:flex; gap:8px; justify-content:center; flex-wrap:wrap; align-items:center; margin-bottom:8px;}
  .formula-part{display:inline-flex; align-items:center; gap:6px; font-weight:600;}
  .controls-row{display:flex; gap:12px; align-items:center; justify-content:center; margin-bottom:12px; flex-wrap:wrap;}
  .layout{ display:grid; grid-template-columns: 1fr minmax(280px, 480px); gap:16px; align-items:start; }
  @media (max-width:1100px){ .layout{grid-template-columns:1fr;} }
  table.chem{border-collapse:collapse; width:100%;}
  table.chem caption{caption-side:top; font-weight:700; margin-bottom:8px; text-align:left;}
  table.chem th, table.chem td{border:1px solid var(--border); padding:6px; text-align:center; min-width:46px; background:#fff; vertical-align:middle;}
  table.chem th{background:#e6f0fb; font-weight:700;}
  .elem-cell{background:#fafafa; font-weight:600;}
  input.num{width:100%; border:0; text-align:center; font-size:14px; padding:4px; background:transparent;}
  input.num:focus{outline:1px solid var(--accent); background:#eef7ff;}
  .coef{width:48px; padding:4px; text-align:center; border-radius:6px; border:1px solid #d7eafb; background:#f8fbff;}
  .mol-header{display:flex; flex-direction:column; gap:6px; align-items:center; justify-content:center;}
  .mol-name{font-weight:700; font-size:14px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:80px;}
  .mol-coef-label{font-size:11px; color:#555;}
  .rp-cell{min-height:36px; min-width:64px; display:flex; align-items:center; justify-content:center; background:#fff; transition:color 0.15s, background 0.15s;}
  .rp-zero{color:#333;}
  .rp-pos{color:var(--pos); font-weight:700;}
  .rp-neg{color:var(--neg); font-weight:700;}
  .note{font-size:13px; color:#555; text-align:center; margin-top:8px;}
  .mol-fallback{opacity:0.7; font-style:italic;}
  .rp-header{ white-space:nowrap; vertical-align:middle; }

  .vector-panel{ background:#fff; border:1px solid #e2eefc; border-radius:10px; padding:8px; max-width:100%; overflow:hidden; }
  .vector-title{font-weight:700; font-size:15px; margin-bottom:8px; text-align:center;}
  .vector-svg{ width:100%; height:auto; display:block; background:linear-gradient(180deg,#fbfeff,#f7fbff); border-radius:8px; border:1px solid #e6f7ff; max-width:100%; overflow:hidden; }

  .axis-labels{display:flex; justify-content:space-between; align-items:center; margin-top:6px; gap:8px; padding:0 6px;}
  .axis-labels .x-label{flex:1; text-align:center; font-weight:600; color:#234;}
  .axis-labels .y-label{width:48px; text-align:left; font-weight:600; color:#234;}
  .vector-legend{font-size:13px; margin-top:8px; color:#444; text-align:center;}
  .method-def{font-size:13px; margin-top:10px; color:#333; background:#fbfdff; padding:8px; border-radius:6px; border:1px solid #eef6ff;}
  .method-def b{color:#112;}
  .axis-selectors{display:flex; gap:8px; justify-content:center; align-items:center; margin-bottom:8px; flex-wrap:wrap;}
  .axis-selectors label{font-size:13px; color:#333;}

  /* Updated mapping note styles for readability */
  .mapping-note-inline{font-size:14px; color:#2b4758; margin-top:8px; padding:6px 8px; background:#f7fbff; border-radius:6px; border:1px solid #e1f0ff; text-align:center; white-space:normal; line-height:1.3;}
  @media (max-width:880px){ .coef{width:40px;} table.chem th, table.chem td{font-size:13px; padding:6px;} .formula-box{font-size:15px;} }
</style>
</head>
<body>

<div class="chem-wrap">
  <div class="title">Інтерактивна таблиця — баланс реакції + вектори</div>

  <div class="eq" aria-live="polite">
    <div class="formula-box" id="equation"></div>
    <div style="font-size:13px; color:#444;">(Реагенти зліва — Продукти справа)</div>
  </div>

  <div class="controls-row">
    <div style="font-size:13px; color:#444;">Оберіть осі для векторів (X, Y):</div>
    <div class="axis-selectors" id="axisSelectors"></div>
  </div>

  <div class="layout">
    <div>
      <table class="chem" id="mainTable" aria-label="Таблиця елементів і молекул">
        <caption>Таблиця атомних індексів у молекулах і вектори по осях</caption>
        <thead>
          <tr>
            <th scope="col" rowspan="2">Елемент</th>
            <th scope="col" rowspan="2">X</th>
            <th scope="col" rowspan="2">Y</th>
            <th scope="col" colspan="3">Реагенти</th>
            <th scope="col" rowspan="2" class="rp-header">R − P</th>
            <th scope="col" colspan="5">Продукти</th>
          </tr>
          <tr id="moleculeHeaders"></tr>
        </thead>
        <tbody id="elementsBody"></tbody>
      </table>

      <div class="note">Змінюй числа індексів або коефіцієнти — рівняння, різниця (R − P) та вектори оновлюються автоматично. Якщо коефіцієнт 0 — молекулу не показуємо; 1 — цифру 1 не показуюмо.</div>
    </div>

    <div class="vector-panel" aria-label="Панель векторів">
      <div class="vector-title">Координатна сітка — векторні шляхи реагентів і продуктів</div>

      <svg id="vectorSvg" class="vector-svg" viewBox="0 0 520 520" preserveAspectRatio="xMidYMid meet" role="img" aria-label="Координатна сітка"></svg>

      <div class="axis-labels" aria-hidden="false">
        <div class="y-label" id="axisLabelY">Y:</div>
        <div class="x-label" id="axisLabelX">X:</div>
      </div>

      <div class="vector-legend" id="vectorLegend">
        Тепер візуалізація показує два кумулятивні шляхи: один для реагентів (синій), інший для продуктів (червоний). Кожен сегмент відповідає одній молекулі, масштабований її коефіцієнтом. Баланс математично перевіряється як збіг кінцевих точок.
      </div>

      <div class="method-def" id="methodDef" aria-live="polite">
        <b>Формальні правила (мікро‑справка методу):</b>
        <ol>
          <li><b>Вектор молекули</b>: v = (nₓ · k, nᵧ · k), де nₓ,nᵧ — кількості атомів вибраних елементів у молекулі, k ∈ ℕ₀ — її стехіометричний коефіцієнт.</li>
          <li><b>Шлях</b>: шлях суміші = впорядкована (послідовна) сума векторів молекул. Тобто path = Σ v_i у порядку малювання; форма залежить від порядку, але кінцева точка — ні (це комутативна сума).</li>
          <li><b>Початкова точка</b>: обидва шляхи починаються з однієї початкової точки (0,0) — нульового вектора.</li>
          <li><b>Баланс</b>: реакція збалансована ⇔ векторна сума реагентів = векторна сума продуктів (кінцеві точки шляхів збігаються).</li>
          <li><b>Проєкція</b>: вибір осей X,Y — це проєкція багатовимірного балансу на площину; збіг у 2D не гарантує повного балансу по всіх елементах, але незбіг у 2D гарантує незбалансованість.</li>
          <li><b>Коефіцієнти</b>: стехіометричні коефіцієнти — цілі невідʼємні числа (ℕ₀). Інтерфейс забезпечує цю умову (min=0, step=1, округлення) і накладає обмеження max для уникнення перевантаження візуалізації.</li>
          <li><b>Умови застосовності</b>: метод застосовний якщо задано принаймні один реагент і один продукт, обрано дві осі, і є принаймні один ненульовий вектор у проєкції.</li>
        </ol>
      </div>

      <!-- mapping note placeholder (created once) -->
      <div class="mapping-note-inline" id="mappingNote" aria-hidden="false"></div>
    </div>
  </div>
</div>

<script>
document.addEventListener("DOMContentLoaded", () => {
  // IMPORTANT: comments preserved (order affects shape only; negative coordinates allowed; NOTE about 2D != full balance)
  const elements = ["H","C","O","N","P","S","F","Na","Ca"];
  const reactants = [
    {id:"h2o", label:"H2O"},
    {id:"co2", label:"CO2"},
    {id:"o2",  label:"O2"}
  ];
  const products = [
    {id:"h2",   label:"H2"},
    {id:"o3",   label:"O3"},
    {id:"h2co3",label:"H2CO3"},
    {id:"n2",   label:"N2"},
    {id:"nh3",  label:"NH3"}
  ];

  const MAX_COEF = 100;
  const defaultIndexMap = {
    h2o: {H:2,O:1},
    co2: {C:1,O:2},
    o2:  {O:2},
    h2:  {H:2},
    o3:  {O:3},
    h2co3:{H:2,C:1,O:3},
    n2:  {N:2},
    nh3: {N:1,H:3}
  };
  const warnedMissingMol = new Set();

  const headerRow = document.getElementById("moleculeHeaders");
  function makeMolHeaderCell(mol){
    const th = document.createElement("th");
    th.setAttribute("scope","col");
    th.innerHTML = `
      <div class="mol-header">
        <div class="mol-name" data-mol="${mol.id}" id="name_${mol.id}" title="${mol.label}">${mol.label}</div>
        <div class="mol-coef-label">
          <input class="coef" aria-label="Коефіцієнт ${mol.label}" data-mol="${mol.id}" type="number" min="0" max="${MAX_COEF}" step="1" value="1">
        </div>
      </div>`;
    return th;
  }
  reactants.forEach(m => headerRow.appendChild(makeMolHeaderCell(m)));
  products.forEach(m => headerRow.appendChild(makeMolHeaderCell(m)));

  const body = document.getElementById("elementsBody");
  elements.forEach((elem, idx) => {
    const tr = document.createElement("tr");
    const tdElem = document.createElement("td"); tdElem.className = "elem-cell"; tdElem.textContent = elem; tr.appendChild(tdElem);
    const tdX = document.createElement("td");
    tdX.innerHTML = `<input type="radio" name="axis-x" aria-label="Обрати ${elem} як X" value="${elem}" ${idx===0 ? "checked" : ""}>`;
    tr.appendChild(tdX);
    const tdY = document.createElement("td");
    tdY.innerHTML = `<input type="radio" name="axis-y" aria-label="Обрати ${elem} як Y" value="${elem}" ${idx===1 ? "checked" : ""}>`;
    tr.appendChild(tdY);

    reactants.forEach(m => {
      const td = document.createElement("td");
      td.innerHTML = `<input class="num cell left" data-mol="${m.id}" data-elem="${elem}" type="number" value="${defaultIndex(m.id, elem)}" min="0" step="1" aria-label="Індекс елемента ${elem} в молекулі ${m.label}">`;
      tr.appendChild(td);
    });

    const rpTd = document.createElement("td"); rpTd.className = "rp-cell"; rpTd.id = `rp_${elem}`; rpTd.textContent = "0"; tr.appendChild(rpTd);

    products.forEach(m => {
      const td = document.createElement("td");
      td.innerHTML = `<input class="num cell right" data-mol="${m.id}" data-elem="${elem}" type="number" value="${defaultIndex(m.id, elem)}" min="0" step="1" aria-label="Індекс елемента ${elem} в молекулі ${m.label}">`;
      tr.appendChild(td);
    });

    body.appendChild(tr);
  });

  function defaultIndex(mol, elem){
    if(!defaultIndexMap[mol]){
      if(!warnedMissingMol.has(mol)){
        console.warn(`defaultIndex: немає запису для молекули ${mol} у defaultIndexMap — повертаю 0`);
        warnedMissingMol.add(mol);
      }
      return 0;
    }
    return (defaultIndexMap[mol][elem]) ? defaultIndexMap[mol][elem] : 0;
  }

  function qAll(selector){ return Array.from(document.querySelectorAll(selector)); }
  function q(selector){ return document.querySelector(selector); }

  function buildFormulaHTML(molId){
    const parts = [];
    elements.forEach(el => {
      const input = document.querySelector(`.cell[data-mol="${molId}"][data-elem="${el}"]`);
      const val = input ? Number(input.value) || 0 : 0;
      if(val > 0) parts.push(el + (val > 1 ? `${val}` : ""));
    });
    return parts.length ? parts.join("") : `<span class="mol-fallback">${molId}</span>`;
  }

  function updateDifference(){
    elements.forEach(elem => {
      let leftSum = 0;
      qAll(`.left[data-elem="${elem}"]`).forEach(input => {
        const molId = input.dataset.mol;
        const coefInput = q(`.coef[data-mol="${molId}"]`);
        const coef = coefInput ? Math.max(0, Math.min(MAX_COEF, Math.floor(Number(coefInput.value) || 0))) : 0;
        leftSum += (Number(input.value) || 0) * coef;
      });
      let rightSum = 0;
      qAll(`.right[data-elem="${elem}"]`).forEach(input => {
        const molId = input.dataset.mol;
        const coefInput = q(`.coef[data-mol="${molId}"]`);
        const coef = coefInput ? Math.max(0, Math.min(MAX_COEF, Math.floor(Number(coefInput.value) || 0))) : 0;
        rightSum += (Number(input.value) || 0) * coef;
      });
      const diff = leftSum - rightSum;
      const cell = document.getElementById(`rp_${elem}`);
      if(!cell) return;
      cell.textContent = diff;
      cell.classList.remove("rp-pos","rp-neg","rp-zero");
      if(diff > 0) cell.classList.add("rp-pos");
      else if(diff < 0) cell.classList.add("rp-neg");
      else cell.classList.add("rp-zero");
    });
  }

  const svg = document.getElementById("vectorSvg");
  svg.setAttribute('overflow','hidden');
  const svgSize = 520;
  const padding = 34;
  const mappingNoteEl = document.getElementById('mappingNote');

  function drawVectors(){
    while (svg.firstChild) svg.removeChild(svg.firstChild);

    const axes = getSelectedAxes();
    const axisLabelX = document.getElementById('axisLabelX');
    const axisLabelY = document.getElementById('axisLabelY');
    if(axisLabelX) axisLabelX.textContent = `X: ${axes.x}`;
    if(axisLabelY) axisLabelY.textContent = `Y: ${axes.y}`;

    function readCount(molId, elemName){
      const inp = q(`.cell[data-mol="${molId}"][data-elem="${elemName}"]`);
      return inp ? Math.max(0, Math.floor(Number(inp.value) || 0)) : 0;
    }

    function buildCumulativePath(molList){
      const pts = [];
      let current = { x: 0, y: 0 };
      pts.push({ x: current.x, y: current.y });
      molList.forEach((mol) => {
        const coefInput = q(`.coef[data-mol="${mol.id}"]`);
        const coef = coefInput ? Math.max(0, Math.min(MAX_COEF, Math.floor(Number(coefInput.value) || 0))) : 0;
        if(coef === 0) return;
        const vx = readCount(mol.id, axes.x);
        const vy = readCount(mol.id, axes.y);
        const vdx = vx * coef;
        const vdy = vy * coef;
        const next = { x: current.x + vdx, y: current.y + vdy };
        pts.push(next);
        current = next;
      });
      return pts;
    }

    const ptsR = buildCumulativePath(reactants);
    const ptsP = buildCumulativePath(products);

    const allPoints = [];
    ptsR.forEach(p => allPoints.push(p));
    ptsP.forEach(p => allPoints.push(p));
    allPoints.push({ x: 0, y: 0 });

    const visibleReactants = reactants.some(m => {
      const coef = Math.max(0, Math.min(MAX_COEF, Math.floor(Number(q(`.coef[data-mol="${m.id}"]`)?.value || 0))));
      const vx = readCount(m.id, axes.x); const vy = readCount(m.id, axes.y);
      return coef > 0 && (vx !== 0 || vy !== 0);
    });
    const visibleProducts = products.some(m => {
      const coef = Math.max(0, Math.min(MAX_COEF, Math.floor(Number(q(`.coef[data-mol="${m.id}"]`)?.value || 0))));
      const vx = readCount(m.id, axes.x); const vy = readCount(m.id, axes.y);
      return coef > 0 && (vx !== 0 || vy !== 0);
    });

    const methodDefEl = document.getElementById('methodDef');
    if(!visibleReactants || !visibleProducts){
      drawFallbackGrid();
      // DO NOT draw long SVG text; show clear HTML note instead
      if(mappingNoteEl){
        mappingNoteEl.textContent = "Недостатньо даних для побудови обох шляхів: потрібен хоча б один видимий реагент і один видимий продукт (поставте коефіцієнт > 0 та/або виберіть інші осі).";
      }
      if(methodDefEl){
        let note = methodDefEl.querySelector('.applicability-note');
        if(!note){
          note = document.createElement('div');
          note.className = 'applicability-note';
          note.style.marginTop = '8px';
          note.style.color = '#8a2';
          methodDefEl.appendChild(note);
        }
        note.textContent = 'Примітка: метод застосовний лише за умов, зазначених у правилах (п.7).';
      }
      const legend = document.getElementById('vectorLegend');
      if(legend) legend.textContent = "Недостатньо видимих даних для повної візуалізації.";
      return;
    } else {
      // clear mapping note if normal visualization
      if(mappingNoteEl) mappingNoteEl.textContent = '';
      const note = methodDefEl && methodDefEl.querySelector('.applicability-note');
      if(note) note.remove();
    }

    // ... (the rest of drawVectors unchanged: autoscale, draw grid, paths, endpoints, legend update, mapping note update)
    // For brevity in this patch excerpt, keep existing implementation (unchanged) after this point.
    // In the real file the rest of the function continues as before (draw grid, draw paths, compute End_R/End_P, update legend and mappingNoteEl).
    // --- Begin existing continuation ---
    // Compute bounding box in logical/world coordinates
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    allPoints.forEach(p => {
      if(p.x < minX) minX = p.x;
      if(p.x > maxX) maxX = p.x;
      if(p.y < minY) minY = p.y;
      if(p.y > maxY) maxY = p.y;
    });
    if(minX === maxX){ minX -= 1; maxX += 1; }
    if(minY === maxY){ minY -= 1; maxY += 1; }
    const spanX = maxX - minX; const spanY = maxY - minY;
    const padUnits = Math.max(1, 0.1 * Math.max(spanX, spanY));
    minX -= padUnits; maxX += padUnits; minY -= padUnits; maxY += padUnits;
    const innerSize = svgSize - padding * 2;
    const scaleX = innerSize / (maxX - minX);
    const scaleY = innerSize / (maxY - minY);
    const MAX_SCALE = 120; const MIN_SCALE = 4;
    let scale = Math.min(scaleX, scaleY); scale = Math.min(scale, MAX_SCALE); scale = Math.max(scale, MIN_SCALE);
    function worldToSvg(pt){ const x = padding + (pt.x - minX) * scale; const y = padding + (maxY - pt.y) * scale; return { x, y }; }

    const bg = document.createElementNS("http://www.w3.org/2000/svg","rect");
    bg.setAttribute("x","0"); bg.setAttribute("y","0"); bg.setAttribute("width","520"); bg.setAttribute("height","520"); bg.setAttribute("fill","transparent");
    svg.appendChild(bg);

    const maxDots = 400;
    let dotsCount = 0;
    for(let xi = Math.floor(minX); xi <= Math.ceil(maxX); xi++){
      for(let yi = Math.floor(minY); yi <= Math.ceil(maxY); yi++){
        if(dotsCount++ > maxDots) break;
        const s = worldToSvg({ x: xi, y: yi });
        const dot = document.createElementNS("http://www.w3.org/2000/svg","circle");
        dot.setAttribute("cx", s.x.toString()); dot.setAttribute("cy", s.y.toString()); dot.setAttribute("r", "2"); dot.setAttribute("fill", "#d9eefe");
        svg.appendChild(dot);
      }
      if(dotsCount > maxDots) break;
    }

    const originSvg = worldToSvg({ x: 0, y: 0 });
    const axesGroup = document.createElementNS("http://www.w3.org/2000/svg","g");
    if(originSvg.x >= padding - 1 && originSvg.x <= svgSize - padding + 1 && originSvg.y >= padding - 1 && originSvg.y <= svgSize - padding + 1) {
      const axisX = document.createElementNS("http://www.w3.org/2000/svg","line");
      axisX.setAttribute("x1", (padding).toString()); axisX.setAttribute("y1", originSvg.y.toString()); axisX.setAttribute("x2", (svgSize - padding).toString()); axisX.setAttribute("y2", originSvg.y.toString()); axisX.setAttribute("stroke","#79a9d9"); axisX.setAttribute("stroke-width","1");
      axesGroup.appendChild(axisX);
      const axisY = document.createElementNS("http://www.w3.org/2000/svg","line");
      axisY.setAttribute("x1", originSvg.x.toString()); axisY.setAttribute("y1", (padding).toString()); axisY.setAttribute("x2", originSvg.x.toString()); axisY.setAttribute("y2", (svgSize - padding).toString()); axisY.setAttribute("stroke","#79a9d9"); axisY.setAttribute("stroke-width","1");
      axesGroup.appendChild(axisY);
    } else {
      const axisX = document.createElementNS("http://www.w3.org/2000/svg","line");
      axisX.setAttribute("x1", (padding).toString()); axisX.setAttribute("y1", (svgSize - padding).toString()); axisX.setAttribute("x2", (svgSize - padding).toString()); axisX.setAttribute("y2", (svgSize - padding).toString()); axisX.setAttribute("stroke","#79a9d9"); axisX.setAttribute("stroke-width","1");
      axesGroup.appendChild(axisX);
      const axisY = document.createElementNS("http://www.w3.org/2000/svg","line");
      axisY.setAttribute("x1", (padding).toString()); axisY.setAttribute("y1", (padding).toString()); axisY.setAttribute("x2", (padding).toString()); axisY.setAttribute("y2", (svgSize - padding).toString()); axisY.setAttribute("stroke","#79a9d9"); axisY.setAttribute("stroke-width","1");
      axesGroup.appendChild(axisY);
    }
    svg.appendChild(axesGroup);

    function drawPath(points, color, id){
      if(!points || points.length < 2) return;
      const d = points.map((pt, idx) => {
        const s = worldToSvg(pt);
        return (idx === 0 ? `M ${s.x} ${s.y}` : `L ${s.x} ${s.y}`);
      }).join(" ");
      const path = document.createElementNS("http://www.w3.org/2000/svg","path");
      path.setAttribute("d", d); path.setAttribute("fill", "none"); path.setAttribute("stroke", color); path.setAttribute("stroke-width", "3"); path.setAttribute("stroke-linecap", "round"); path.setAttribute("stroke-linejoin", "round"); path.setAttribute("data-id", id);
      svg.appendChild(path);
      for(let i = 0; i < points.length; i++){
        const s = worldToSvg(points[i]);
        const c = document.createElementNS("http://www.w3.org/2000/svg","circle");
        c.setAttribute("cx", s.x.toString()); c.setAttribute("cy", s.y.toString()); c.setAttribute("r", (i === 0 ? "3.2" : "2.2")); c.setAttribute("fill", i === 0 ? "#fff" : color); c.setAttribute("stroke", color); c.setAttribute("stroke-width", i === 0 ? "1.5" : "0.8");
        svg.appendChild(c);
      }
    }

    const colorR = "#5da0e8";
    const colorP = "#e85d5d";
    drawPath(ptsR, colorR, "reactants");
    drawPath(ptsP, colorP, "products");

    const endR = ptsR.length ? ptsR[ptsR.length - 1] : {x:0,y:0};
    const endP = ptsP.length ? ptsP[ptsP.length - 1] : {x:0,y:0};
    const eRsv = worldToSvg(endR);
    const ePsv = worldToSvg(endP);

    function drawEndpoint(svgPos, color, label, worldPt){
      const g = document.createElementNS("http://www.w3.org/2000/svg","g");
      const circ = document.createElementNS("http://www.w3.org/2000/svg","circle");
      circ.setAttribute("cx", svgPos.x.toString()); circ.setAttribute("cy", svgPos.y.toString()); circ.setAttribute("r", "4.6"); circ.setAttribute("fill", "#fff"); circ.setAttribute("stroke", color); circ.setAttribute("stroke-width", "2"); g.appendChild(circ);
      const txt = document.createElementNS("http://www.w3.org/2000/svg","text");
      txt.setAttribute("x", (svgPos.x + 8).toString()); txt.setAttribute("y", (svgPos.y + 4).toString()); txt.setAttribute("font-size", "11"); txt.setAttribute("fill", "#214"); txt.textContent = `${label} (${worldPt.x}, ${worldPt.y})`; g.appendChild(txt);
      svg.appendChild(g);
    }
    drawEndpoint(eRsv, colorR, "R", endR);
    drawEndpoint(ePsv, colorP, "P", endP);

    const eps = 1e-6;
    const balanced = (Math.abs(endR.x - endP.x) <= eps) && (Math.abs(endR.y - endP.y) <= eps);
    const legend = document.getElementById('vectorLegend');
    if(legend){
      if(balanced){
        legend.textContent = `✅ Balanced — векторні підсумки реагентів та продуктів збігаються: (${endR.x}, ${endR.y}).`;
      } else {
        legend.textContent = `❌ Not balanced — векторні підсумки різні. End_R = (${endR.x}, ${endR.y}), End_P = (${endP.x}, ${endP.y}).`;
      }
    }

    // compute rp projection and update mapping note (kept in HTML for readability)
    let sumR_x = 0, sumR_y = 0, sumP_x = 0, sumP_y = 0;
    reactants.forEach(m => {
      const coef = Math.max(0, Math.min(MAX_COEF, Math.floor(Number(q(`.coef[data-mol="${m.id}"]`)?.value || 0))));
      sumR_x += readCount(m.id, axes.x) * coef; sumR_y += readCount(m.id, axes.y) * coef;
    });
    products.forEach(m => {
      const coef = Math.max(0, Math.min(MAX_COEF, Math.floor(Number(q(`.coef[data-mol="${m.id}"]`)?.value || 0))));
      sumP_x += readCount(m.id, axes.x) * coef; sumP_y += readCount(m.id, axes.y) * coef;
    });
    const rpProjX = sumR_x - sumP_x; const rpProjY = sumR_y - sumP_y;
    if(mappingNoteEl){
      mappingNoteEl.innerHTML = `<div><b>Проєкція (осі ${axes.x}, ${axes.y}):</b></div>
        <div>R−P (з урахуванням коефіцієнтів) = (${rpProjX}, ${rpProjY}) = End_R − End_P (геометрично)</div>
        <div style="color:#665; margin-top:4px;">Примітка: таблиця R−P показує повний багатовимірний баланс, вектори — лише 2D‑проєкцію. 2D‑збіг не гарантує повний баланс у ℝⁿ.</div>`;
    }

  } // end drawVectors

  function drawFallbackGrid(){
    const inner = svgSize - padding * 2;
    const step = inner / 10;
    for(let i=0;i<=10;i++){
      for(let j=0;j<=10;j++){
        const x = padding + i * step;
        const y = padding + (10 - j) * step;
        const dot = document.createElementNS("http://www.w3.org/2000/svg","circle");
        dot.setAttribute("cx", x.toString()); dot.setAttribute("cy", y.toString()); dot.setAttribute("r", "2"); dot.setAttribute("fill", "#d9eefe");
        svg.appendChild(dot);
      }
    }
    const axisX = document.createElementNS("http://www.w3.org/2000/svg","line");
    axisX.setAttribute("x1", padding.toString()); axisX.setAttribute("y1", (svgSize - padding).toString()); axisX.setAttribute("x2", (svgSize - padding).toString()); axisX.setAttribute("y2", (svgSize - padding).toString()); axisX.setAttribute("stroke","#79a9d9"); axisX.setAttribute("stroke-width","1.5"); svg.appendChild(axisX);
    const axisY = document.createElementNS("http://www.w3.org/2000/svg","line");
    axisY.setAttribute("x1", padding.toString()); axisY.setAttribute("y1", padding.toString()); axisY.setAttribute("x2", padding.toString()); axisY.setAttribute("y2", (svgSize - padding).toString()); axisY.setAttribute("stroke","#79a9d9"); axisY.setAttribute("stroke-width","1.5"); svg.appendChild(axisY);
  }

  function getSelectedAxes(){
    const x = q('input[name="axis-x"]:checked')?.value || elements[0];
    const y = q('input[name="axis-y"]:checked')?.value || elements[1] || elements[0];
    if(x === y){
      for(const el of elements){
        if(el !== x){
          const r = q(`input[name="axis-y"][value="${el}"]`);
          if(r) r.checked = true;
          return { x, y: el };
        }
      }
    }
    return { x, y };
  }

  const axisSelectors = document.getElementById("axisSelectors");
  function buildAxisSelectors(){
    axisSelectors.innerHTML = "";
    const createSelect = (labelText, name) => {
      const wrapper = document.createElement('div');
      wrapper.style.display = 'flex'; wrapper.style.flexDirection = 'column'; wrapper.style.alignItems = 'center'; wrapper.style.gap = '6px';
      const lbl = document.createElement('label'); lbl.textContent = labelText; lbl.style.fontWeight = '600'; lbl.style.fontSize = '13px'; wrapper.appendChild(lbl);
      const sel = document.createElement('select'); sel.style.fontSize = '13px'; sel.style.padding = '4px';
      elements.forEach((el, idx) => { const opt = document.createElement('option'); opt.value = el; opt.textContent = el; if((name === 'x' && idx === 0) || (name === 'y' && idx === 1)) opt.selected = true; sel.appendChild(opt); });
      sel.addEventListener('change', () => {
        const val = sel.value;
        const radioName = name === 'x' ? 'axis-x' : 'axis-y';
        const r = q(`input[name="${radioName}"][value="${val}"]`);
        if(r) r.checked = true;
        const otherSel = axisSelectors.querySelector(`select[data-axis="${name === 'x' ? 'y' : 'x'}"]`);
        if(otherSel && otherSel.value === val){
          for(const el of elements){ if(el !== val){ otherSel.value = el; const otherRadio = q(`input[name="${name === 'x' ? 'axis-y' : 'axis-x'}"][value="${el}"]`); if(otherRadio) otherRadio.checked = true; break; } }
        }
        drawVectors();
      });
      sel.setAttribute('data-axis', name);
      wrapper.appendChild(sel);
      return wrapper;
    };
    axisSelectors.appendChild(createSelect('X', 'x'));
    axisSelectors.appendChild(createSelect('Y', 'y'));
    qAll('input[name="axis-x"]').forEach(r => r.addEventListener('change', () => { const val = r.value; const sel = axisSelectors.querySelector('select[data-axis="x"]'); if(sel) sel.value = val; drawVectors(); }));
    qAll('input[name="axis-y"]').forEach(r => r.addEventListener('change', () => { const val = r.value; const sel = axisSelectors.querySelector('select[data-axis="y"]'); if(sel) sel.value = val; drawVectors(); }));
  }

  function buildEquation(){
    const leftParts = [];
    reactants.forEach(m => {
      const coefInput = document.querySelector(`.coef[data-mol="${m.id}"]`);
      const coef = coefInput ? Math.max(0, Math.min(MAX_COEF, Math.floor(Number(coefInput.value) || 0))) : 0;
      if(coef === 0) return;
      const formula = buildFormulaHTML(m.id); leftParts.push((coef>1?coef:'') + formula);
    });
    const rightParts = [];
    products.forEach(m => {
      const coefInput = document.querySelector(`.coef[data-mol="${m.id}"]`);
      const coef = coefInput ? Math.max(0, Math.min(MAX_COEF, Math.floor(Number(coefInput.value) || 0))) : 0;
      if(coef === 0) return;
      const formula = buildFormulaHTML(m.id); rightParts.push((coef>1?coef:'') + formula);
    });
    const joiner = ' <span style="color:#666; font-weight:600">+</span> ';
    const leftHTML = leftParts.length ? leftParts.join(joiner) : '<span style="color:#999">—</span>';
    const rightHTML = rightParts.length ? rightParts.join(joiner) : '<span style="color:#999">—</span>';
    document.getElementById("equation").innerHTML = `<div class="formula-part">${leftHTML}</div><div style="font-weight:700; padding:0 8px"> = </div><div class="formula-part">${rightHTML}</div>`;
  }

  function onChangeHandler(){
    qAll('.coef').forEach(coefEl => { coefEl.value = Math.max(0, Math.min(MAX_COEF, Math.floor(Number(coefEl.value) || 0))); });
    [...reactants, ...products].forEach(m => { const nameEl = document.getElementById(`name_${m.id}`); if(nameEl) nameEl.innerHTML = buildFormulaHTML(m.id); });
    buildEquation(); updateDifference(); drawVectors();
  }

  qAll("input.num").forEach(inp => inp.addEventListener("input", onChangeHandler));
  qAll("input.coef").forEach(inp => { inp.addEventListener("input", () => { inp.value = Math.max(0, Math.min(MAX_COEF, Math.floor(Number(inp.value) || 0))); onChangeHandler(); }); });

  buildAxisSelectors();
  [...reactants, ...products].forEach(m => {
    const coef = document.querySelector(`.coef[data-mol="${m.id}"]`);
    const any = elements.some(el => { const cell = document.querySelector(`.cell[data-mol="${m.id}"][data-elem="${el}"]`); return cell && Number(cell.value) > 0; });
    if(coef) coef.value = any ? (coef.value || 1) : 0;
  });

  onChangeHandler();
  window.addEventListener('resize', () => drawVectors());
});
</script>

</body>
</html>